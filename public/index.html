<!DOCTYPE html>
<html>
<head>
    <style type=text/css>
    * {
            margin: 0px;
            padding: 0px;
        }
        body {
            background-color: rgb(0, 255, 0);
            position: relative;
            overflow: hidden;
            /* これによってコメントが長くても折り返さないようになる */
            white-space: nowrap;
            
        }

        #ruler {
            font-size: 9vh;
            font-weight: 900;
            font-family: "Segoe UI Emoji", "MS P ゴシック";
        }

        .chat {
            color: rgb(255, 255, 255);
            font-weight: 900;
            font-size: 9vh;
            font-family: "Segoe UI Emoji", "MS P ゴシック";
            position: absolute;
            will-change: left, transform;
            animation: commentMove 5s linear;

            /* これをつけることによって移動が終わっても画面から消えたところで固定される */
            animation-fill-mode: forwards;

            text-shadow: rgb(0, 0, 0) 4px 0px 0px, rgb(0, 0, 0) 3.87565px 0.989616px 0px, rgb(0, 0, 0) 3.51033px 1.9177px 0px, rgb(0, 0, 0) 2.92676px 2.72656px 0px, rgb(0, 0, 0) 2.16121px 3.36588px 0px, rgb(0, 0, 0) 1.26129px 3.79594px 0px, rgb(0, 0, 0) 0.282949px 3.98998px 0px, rgb(0, 0, 0) -0.712984px 3.93594px 0px, rgb(0, 0, 0) -1.66459px 3.63719px 0px, rgb(0, 0, 0) -2.51269px 3.11229px 0px, rgb(0, 0, 0) -3.20457px 2.39389px 0px, rgb(0, 0, 0) -3.69721px 1.52664px 0px, rgb(0, 0, 0) -3.95997px 0.56448px 0px, rgb(0, 0, 0) -3.97652px -0.432781px 0px, rgb(0, 0, 0) -3.74583px -1.40313px 0px, rgb(0, 0, 0) -3.28224px -2.28625px 0px, rgb(0, 0, 0) -2.61457px -3.02721px 0px, rgb(0, 0, 0) -1.78435px -3.57996px 0px, rgb(0, 0, 0) -0.843183px -3.91012px 0px, rgb(0, 0, 0) 0.150409px -3.99717px 0px, rgb(0, 0, 0) 1.13465px -3.8357px 0px, rgb(0, 0, 0) 2.04834px -3.43574px 0px, rgb(0, 0, 0) 2.83468px -2.82216px 0px, rgb(0, 0, 0) 3.44477px -2.03312px 0px, rgb(0, 0, 0) 3.84068px -1.11766px 0px, rgb(0, 0, 0) 3.9978px -0.132717px 0px;
        }

        @keyframes commentMove {
            0% {
                left: 100%;
                transform: translateX(0%);
            }
            100% {
                left: 0%;
                transform: translateX(-100%);
            }
        }
    </style>
</head>
<body>
    <div id="placeholder"></div>
    <!-- 要素の幅を取得するために利用するDOM -->
    <span id="ruler" style="visibility:hidden;position:absolute;white-space:nowrap;"></span>
    <!-- /socket.io/socket.io.js は自動で生成されるので作成する必要はない -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <script>
        let socket = io();

        // ブラウザに何行のコメントを表示するか
        const windowDevided = 11;
        // コメント1行の高さを取得
        let commentHeight = Math.round(document.documentElement.clientHeight/windowDevided);
        let commentMoveWidth = document.documentElement.clientWidth;
        // コメントの表示時間(単位：ms)
        const commentDisplayTime = 5000;

        // 各行の情報を持つ配列の作成
        let row = Array(windowDevided);
        for (let i=0; i<windowDevided; i++) {
            row[i] = {
                bornTime: 0,
                speed: 0,
                width: 0,
            }
        }
        // 接続時の処理
        socket.on('connect', () => {
            console.log("socket.ioに接続しました");
        });

        // サーバーからのメッセージ拡散に対する処理
        socket.on('spread message', (strMessage) => {
            // OPENRECのコメントがスタンプの場合は処理しない
            if(strMessage.length == 0) return;

            // 流れるコメントの作成
            calcRow(strMessage);
        });

        window.onresize = () => {
            commentHeight = Math.round(document.documentElement.clientHeight/windowDevided);
            commentMoveWidth = document.documentElement.clientWidth;
        }

        setInterval(commentDelete, commentDisplayTime);


        function calcRow(commentMessage) {
            let comment = {
                bornTime: Date.now(),
                flowRow: 0,
                minCollisionWidth: commentMoveWidth,
                width: strWidth(commentMessage),
            };
            comment.speed = (commentMoveWidth + comment.width)/commentDisplayTime;
            
            for (let i=0; i<row.length; i++) {
                let relativeSpeed = comment.speed - row[i].speed;
                let timeLag = comment.bornTime - row[i].bornTime;
                let rowCommentRightSide = row[i].speed * timeLag - row[i].width
                let collisionWidth = relativeSpeed * (commentDisplayTime - timeLag) - rowCommentRightSide;
                
                // 行にコメントが存在していない時
                if (timeLag >= commentDisplayTime) {
                    createComment(commentMessage, comment, row, i);
                    break;

                // コメントが行の右側まで出ていて、衝突しない時
                } else if (rowCommentRightSide >= 0 && collisionWidth <= 0) {   
                    createComment(commentMessage, comment, row, i);
                    break;
                }

                /*
                    見栄えが悪くなるので衝突するコメントは表示しないことにした
                */
                // // 衝突する場合は一番接触時間が短い行を探す為に保留
                // } else if (comment.minCollisionWidth > collisionWidth) {
                //     comment.minCollisionWidth = collisionWidth;
                //     comment.flowRow = i;
                //     continue;

                // // どの行に流しても衝突している場合は一番接触時間が短い行に流す
                // } else if (i == row.length - 1) {
                //     row[comment.flowRow].bornTime = comment.bornTime;
                //     row[comment.flowRow].speed = comment.speed;
                //     row[comment.flowRow].width = comment.width;
                //     console.log(`${i+1}ループ：${comment.flowRow+1}に流します`);
                //     console.log(`生成時間：${row[comment.flowRow].bornTime} 速度：${row[comment.flowRow].speed} コメント幅:${row[comment.flowRow].width}`);
                //     createComment(commentMessage, comment);
                //     break;
                // }
            }


            // // コメントをどこに配置出来るか？
            // for (let i = 0; i < rowCommentDeleteTime.length; i++) {
            //     // 行からコメントが削除されているかの確認用変数
            //     let compareDeleteTime = comment.bornTime - rowCommentDeleteTime[i];
            //     //console.log(compareDeleteTime);
            //     if (comment.length < rowCommentLength || compareDeleteTime >= commentDisplayTime) {
            //         // コメントを流す処理をする
            //         rowCommentDeleteTime[i] = comment.bornTime;
            //         rowCommentLength[i] = comment.length;
            //         comment.flowRow = i;
            //         break;
            //         // コメントをそこに流さない場合、今あるコメントが一番早くコメントが流れ終わる場所を探す
            //     } else if (comment.maxDisappearTime < compareDeleteTime) {
            //         //console.log(`compare:${i+1} ${compareDeleteTime}`)
            //         comment.maxDisappearTime = compareDeleteTime;
            //         comment.flowRow = i;
            //         continue;
            //         // 最後まで条件を満たす行がなかった時、一番早くコメントが流れ終わっている行に流す
            //     } else if (i == rowCommentDeleteTime.length - 1) {
            //         rowCommentDeleteTime[comment.flowRow] = comment.bornTime;
            //         rowCommentLength[comment.flowRow] = comment.length;
            //         console.log(`${i+1}回目のループ：${comment.flowRow}に流す`)
            //         break;
            //     }
            // }
            
            
        }

        const createComment = (strMessage, comment, row, index) => {
            row[index].bornTime = comment.bornTime;
            row[index].speed = comment.speed;
            row[index].width = comment.width;
            comment.flowRow = index;
            // コメントのDOMの作成時刻を持たせる
            const wrapper = $(`<div data-timelimit=${comment.bornTime+commentDisplayTime}>`);      
            wrapper.attr("class", "chat");
            // CSSを付与
            wrapper.css("top", commentHeight * comment.flowRow);
            // wrapperにID:chatを付加
            wrapper.append(strMessage);
            
                
            // placeholderにwrapperを追加
            //console.log(`コメントを流します: ${comment.flowRow+1}行目`)
                
                
            //setTimeout(function() {wrapper.remove();}, commentDisplayTime);
            $('#placeholder').append(wrapper);
        }

        function commentDelete() {
            let updateTime = Date.now()
            // placeholder要素内の全ての子要素に対して以下の操作を行う
            $(placeholder).children().each((index, i) => {
                if(updateTime - $(i).attr("data-timelimit") >= 0) $(i).remove();
            });
            //setTimeout(updateTimeLimit, intervalTime);
            console.log("コメント削除関数を呼び出し完了")
        }

        function strWidth(str) {
            let e = $("#ruler");
            let width = e.text(str).get(0).offsetWidth;
            e.empty();
            return width;
        }
    </script>
</body>
</html>

<!-- 
    コメントが衝突する為の条件
        その行で表示されているコメントの一番右にあるもの：旧コメント
        これから流すコメント：新コメント
            と定義する
        
        コメントを流す時点で
            旧コメントの右側座標：移動距離[旧コメント速度 * (新コメント発生時間 - 旧コメント発生時間)] - コメント幅
        移動している

        (新コメントの速度 - 旧コメントの速度) * 残り時間[旧コメント削除時間[旧コメント発生時間 + コメント表示時間] - 新コメント発生時間] >= 旧コメントの右側座標
            となる場合、新コメントが追い抜く形になるので衝突する

    どの行に流すかのロジックは
        1.コメントは流れているが新コメントが遅いので追いつかない(旧コメントの速度 >= 新コメントの速度)
        2.その行にコメントが流れていない
    の順番で考えると上の段に詰まったコメントになる

    また、どの行でも衝突してしまう場合は、各々の行で
        (新コメントの速度 - 旧コメントの速度) * 残り時間 - 旧コメントの右側座標
    を考え、その値が一番小さいものを利用したい

    結果的には
        コメントが追いつかないかどうかで場合分けをすれば良い

    必要になるもの
        速度に必要：画面の幅、コメントの幅、表示時間
        衝突に必要：コメント発生時間
    配列に保持しておきたいもの
        旧コメントの速度、発生時間
 -->