<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="index.css">
</head>
<body>
    <div id="placeholder"></div>
    <!-- 要素の幅を取得するために利用するDOM -->
    <span id="ruler" style="visibility:hidden;position:absolute;white-space:nowrap;"></span>
    <!-- /socket.io/socket.io.js は自動で生成されるので作成する必要はない -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <script>
        let socket = io();

        // ブラウザに何行のコメントを表示するか
        const windowDevided = 11;
        // コメント1行の高さを取得
        let commentHeight = Math.round(document.documentElement.clientHeight/windowDevided);
        let commentMoveWidth = document.documentElement.clientWidth;
        // コメントの表示時間(単位：ms)
        const commentDisplayTime = 5000;

        // 各行の情報を持つ配列の作成
        let row = Array(windowDevided);
        for (let i=0; i<windowDevided; i++) {
            row[i] = {
                bornTime: 0,
                speed: 0,
                width: 0,
            }
        }
        // 接続時の処理
        socket.on('connect', () => {
            console.log("socket.ioに接続しました");
        });

        // サーバーからのメッセージ拡散に対する処理
        socket.on('spread message', (strMessage) => {
            // OPENRECのコメントがスタンプの場合は処理しない
            if(strMessage.length == 0) return;

            // 流れるコメントの作成
            calcRow(strMessage);
        });

        window.onresize = () => {
            commentHeight = Math.round(document.documentElement.clientHeight/windowDevided);
            commentMoveWidth = document.documentElement.clientWidth;
        }

        setInterval(commentDelete, commentDisplayTime);


        function calcRow(commentMessage) {
            let comment = {
                bornTime: Date.now(),
                flowRow: 0,
                minCollisionWidth: commentMoveWidth,
                width: strWidth(commentMessage),
                flag: false,
            };
            comment.speed = (commentMoveWidth + comment.width)/commentDisplayTime;
            
            for (let i=0; i<row.length; i++) {
                let relativeSpeed = comment.speed - row[i].speed;
                let timeLag = comment.bornTime - row[i].bornTime;
                let rowCommentRightSide = row[i].speed * timeLag - row[i].width
                let collisionWidth = relativeSpeed * (commentDisplayTime - timeLag) - rowCommentRightSide;
                
                // 行にコメントが存在していない時
                if (timeLag >= commentDisplayTime) {
                    createComment(commentMessage, comment, row, i);
                    break;

                // コメントが行の右側まで出ていて、衝突しない時
                } else if (rowCommentRightSide >= 0 && collisionWidth <= 0) {   
                    createComment(commentMessage, comment, row, i);
                    break;
                }
                /*
                    見栄えが悪くなるので衝突するコメントは表示しないことにした
                */
                // // 衝突する場合は一番接触時間が短い行を探す為に保留
                // } else if ((collisionWidth <= commentMoveWidth/10) && (comment.minCollisionWidth > collisionWidth)) {
                //     comment.minCollisionWidth = collisionWidth;
                //     comment.flowRow = i;
                //     comment.flag = true;
                //     continue;

                // // どの行に流しても衝突している場合は一番接触時間が短い行に流す
                // } else if (i == row.length - 1 && comment.flag == true) {
                //     createComment(commentMessage, comment, row, comment.flowRow);
                //     break;
                // }
            }


            // // コメントをどこに配置出来るか？
            // for (let i = 0; i < rowCommentDeleteTime.length; i++) {
            //     // 行からコメントが削除されているかの確認用変数
            //     let compareDeleteTime = comment.bornTime - rowCommentDeleteTime[i];
            //     //console.log(compareDeleteTime);
            //     if (comment.length < rowCommentLength || compareDeleteTime >= commentDisplayTime) {
            //         // コメントを流す処理をする
            //         rowCommentDeleteTime[i] = comment.bornTime;
            //         rowCommentLength[i] = comment.length;
            //         comment.flowRow = i;
            //         break;
            //         // コメントをそこに流さない場合、今あるコメントが一番早くコメントが流れ終わる場所を探す
            //     } else if (comment.maxDisappearTime < compareDeleteTime) {
            //         //console.log(`compare:${i+1} ${compareDeleteTime}`)
            //         comment.maxDisappearTime = compareDeleteTime;
            //         comment.flowRow = i;
            //         continue;
            //         // 最後まで条件を満たす行がなかった時、一番早くコメントが流れ終わっている行に流す
            //     } else if (i == rowCommentDeleteTime.length - 1) {
            //         rowCommentDeleteTime[comment.flowRow] = comment.bornTime;
            //         rowCommentLength[comment.flowRow] = comment.length;
            //         console.log(`${i+1}回目のループ：${comment.flowRow}に流す`)
            //         break;
            //     }
            // }
            
            
        }

        const createComment = (strMessage, comment, row, index) => {
            row[index].bornTime = comment.bornTime;
            row[index].speed = comment.speed;
            row[index].width = comment.width;
            comment.flowRow = index;
            // コメントのDOMの作成時刻を持たせる
            const wrapper = $(`<div data-timelimit=${comment.bornTime+commentDisplayTime}>`);      
            wrapper.attr("class", "chat");
            // CSSを付与
            wrapper.css("top", commentHeight * comment.flowRow);
            // wrapperにID:chatを付加
            wrapper.append(strMessage);
            
                
            // placeholderにwrapperを追加
            //console.log(`コメントを流します: ${comment.flowRow+1}行目`)
                
                
            //setTimeout(function() {wrapper.remove();}, commentDisplayTime);
            $('#placeholder').append(wrapper);
        }

        function commentDelete() {
            let updateTime = Date.now()
            // placeholder要素内の全ての子要素に対して以下の操作を行う
            $(placeholder).children().each((index, i) => {
                if(updateTime - $(i).attr("data-timelimit") >= 0) $(i).remove();
            });
            //setTimeout(updateTimeLimit, intervalTime);
            console.log("コメント削除関数を呼び出し完了")
        }

        function strWidth(str) {
            let e = $("#ruler");
            let width = e.text(str).get(0).offsetWidth;
            e.empty();
            return width;
        }
    </script>
</body>
</html>

<!-- 
    コメントが衝突する為の条件
        その行で表示されているコメントの一番右にあるもの：旧コメント
        これから流すコメント：新コメント
            と定義する
        
        コメントを流す時点で
            旧コメントの右側座標：移動距離[旧コメント速度 * (新コメント発生時間 - 旧コメント発生時間)] - コメント幅
        移動している

        (新コメントの速度 - 旧コメントの速度) * 残り時間[旧コメント削除時間[旧コメント発生時間 + コメント表示時間] - 新コメント発生時間] >= 旧コメントの右側座標
            となる場合、新コメントが追い抜く形になるので衝突する

    どの行に流すかのロジックは
        1.コメントは流れているが新コメントが遅いので追いつかない(旧コメントの速度 >= 新コメントの速度)
        2.その行にコメントが流れていない
    の順番で考えると上の段に詰まったコメントになる

    また、どの行でも衝突してしまう場合は、各々の行で
        (新コメントの速度 - 旧コメントの速度) * 残り時間 - 旧コメントの右側座標
    を考え、その値が一番小さいものを利用したい

    結果的には
        コメントが追いつかないかどうかで場合分けをすれば良い

    必要になるもの
        速度に必要：画面の幅、コメントの幅、表示時間
        衝突に必要：コメント発生時間
    配列に保持しておきたいもの
        旧コメントの速度、発生時間
 -->